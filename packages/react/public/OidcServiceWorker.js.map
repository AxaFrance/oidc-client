{"version":3,"file":"OidcServiceWorker.js","sources":["../constants.ts","../utils/domains.ts","../utils/strings.ts","../utils/tokens.ts","../utils/serializeHeaders.ts","../utils/sleep.ts","../OidcServiceWorker.ts"],"sourcesContent":["const scriptFilename = 'OidcTrustedDomains.js'; /* global trustedDomains */\r\nconst acceptAnyDomainToken = '*';\r\n\r\ntype TokenType = {\r\n  readonly REFRESH_TOKEN: string;\r\n  readonly ACCESS_TOKEN: string;\r\n  readonly NONCE_TOKEN: string;\r\n  readonly CODE_VERIFIER: string;\r\n};\r\n\r\nconst TOKEN: TokenType = {\r\n  REFRESH_TOKEN: 'REFRESH_TOKEN_SECURED_BY_OIDC_SERVICE_WORKER',\r\n  ACCESS_TOKEN: 'ACCESS_TOKEN_SECURED_BY_OIDC_SERVICE_WORKER',\r\n  NONCE_TOKEN: 'NONCE_SECURED_BY_OIDC_SERVICE_WORKER',\r\n  CODE_VERIFIER: 'CODE_VERIFIER_SECURED_BY_OIDC_SERVICE_WORKER',\r\n};\r\n\r\ntype TokenRenewModeType = {\r\n  readonly access_token_or_id_token_invalid: string;\r\n  readonly access_token_invalid: string;\r\n  readonly id_token_invalid: string;\r\n};\r\n\r\nconst TokenRenewMode: TokenRenewModeType = {\r\n  access_token_or_id_token_invalid: 'access_token_or_id_token_invalid',\r\n  access_token_invalid: 'access_token_invalid',\r\n  id_token_invalid: 'id_token_invalid',\r\n};\r\n\r\nconst openidWellknownUrlEndWith = '/.well-known/openid-configuration';\r\n\r\nexport { scriptFilename, acceptAnyDomainToken, TOKEN, TokenRenewMode, openidWellknownUrlEndWith };\r\n","import { TrustedDomains } from './../types';\r\nimport {\r\n  acceptAnyDomainToken,\r\n  openidWellknownUrlEndWith,\r\n  scriptFilename,\r\n} from '../constants';\r\nimport { Database, Domain, OidcConfig } from '../types';\r\n\r\nfunction checkDomain(domains: Domain[], endpoint: string) {\r\n  if (!endpoint) {\r\n    return;\r\n  }\r\n\r\n  const domain = domains.find((domain) => {\r\n    let testable: RegExp;\r\n\r\n    if (typeof domain === 'string') {\r\n      testable = new RegExp(`^${domain}`);\r\n    } else {\r\n      testable = domain;\r\n    }\r\n\r\n    return testable.test?.(endpoint);\r\n  });\r\n  if (!domain) {\r\n    throw new Error(\r\n      'Domain ' +\r\n        endpoint +\r\n        ' is not trusted, please add domain in ' +\r\n        scriptFilename\r\n    );\r\n  }\r\n}\r\n\r\nconst getCurrentDatabaseDomain = (\r\n  database: Database,\r\n  url: string,\r\n  trustedDomains: TrustedDomains\r\n) => {\r\n  if (url.endsWith(openidWellknownUrlEndWith)) {\r\n    return null;\r\n  }\r\n  for (const [key, currentDatabase] of Object.entries<OidcConfig>(database)) {\r\n    const oidcServerConfiguration = currentDatabase.oidcServerConfiguration;\r\n\r\n    if (!oidcServerConfiguration) {\r\n      continue;\r\n    }\r\n\r\n    if (\r\n      oidcServerConfiguration.tokenEndpoint &&\r\n      url === oidcServerConfiguration.tokenEndpoint\r\n    ) {\r\n      continue;\r\n    }\r\n    if (\r\n      oidcServerConfiguration.revocationEndpoint &&\r\n      url === oidcServerConfiguration.revocationEndpoint\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    const domainsToSendTokens = oidcServerConfiguration.userInfoEndpoint\r\n      ? [oidcServerConfiguration.userInfoEndpoint, ...trustedDomains[key]]\r\n      : [...trustedDomains[key]];\r\n\r\n    let hasToSendToken = false;\r\n    if (domainsToSendTokens.find((f) => f === acceptAnyDomainToken)) {\r\n      hasToSendToken = true;\r\n    } else {\r\n      for (let i = 0; i < domainsToSendTokens.length; i++) {\r\n        let domain = domainsToSendTokens[i];\r\n\r\n        if (typeof domain === 'string') {\r\n          domain = new RegExp(`^${domain}`);\r\n        }\r\n\r\n        if (domain.test?.(url)) {\r\n          hasToSendToken = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (hasToSendToken) {\r\n      if (!currentDatabase.tokens) {\r\n        return null;\r\n      }\r\n      return currentDatabase;\r\n    }\r\n  }\r\n  return null;\r\n};\r\n\r\nexport { checkDomain, getCurrentDatabaseDomain };\r\n","/**\r\n * Count occurances of letter in string\r\n * @param str\r\n * @param find\r\n * @returns\r\n */\r\nexport function countLetter(str: string, find: string) {\r\n  return str.split(find).length - 1;\r\n}\r\n","import { TOKEN, TokenRenewMode } from '../constants';\r\nimport { OidcConfig, OidcConfiguration, OidcServerConfiguration, Tokens } from '../types';\r\nimport { countLetter } from './strings';\r\n\r\nfunction parseJwt(token: string) {\r\n  return JSON.parse(\r\n    b64DecodeUnicode(token.split('.')[1].replace('-', '+').replace('_', '/'))\r\n  );\r\n}\r\nfunction b64DecodeUnicode(str: string) {\r\n  return decodeURIComponent(\r\n    Array.prototype.map\r\n      .call(\r\n        atob(str),\r\n        (c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)\r\n      )\r\n      .join('')\r\n  );\r\n}\r\n\r\nfunction computeTimeLeft(\r\n  refreshTimeBeforeTokensExpirationInSecond: number,\r\n  expiresAt: number\r\n) {\r\n  const currentTimeUnixSecond = new Date().getTime() / 1000;\r\n  return Math.round(\r\n    expiresAt -\r\n      refreshTimeBeforeTokensExpirationInSecond -\r\n      currentTimeUnixSecond\r\n  );\r\n}\r\n\r\nfunction isTokensValid(tokens: Tokens | null) {\r\n  if (!tokens) {\r\n    return false;\r\n  }\r\n  return computeTimeLeft(0, tokens.expiresAt) > 0;\r\n}\r\n\r\nconst extractTokenPayload = (token?: string) => {\r\n  try {\r\n    if (!token) {\r\n      return null;\r\n    }\r\n    if (countLetter(token, '.') === 2) {\r\n      return parseJwt(token);\r\n    } else {\r\n      return null;\r\n    }\r\n  } catch (e) {\r\n    console.warn(e);\r\n  }\r\n  return null;\r\n};\r\n\r\n// https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation (excluding rules #1, #4, #5, #7, #8, #12, and #13 which did not apply).\r\n// https://github.com/openid/AppAuth-JS/issues/65\r\nconst isTokensOidcValid = (\r\n  tokens: Tokens,\r\n  nonce: string | null,\r\n  oidcServerConfiguration: OidcServerConfiguration\r\n): { isValid: boolean; reason: string } => {\r\n  if (tokens.idTokenPayload) {\r\n    const idTokenPayload = tokens.idTokenPayload;\r\n    // 2: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery) MUST exactly match the value of the iss (issuer) Claim.\r\n    if (oidcServerConfiguration.issuer !== idTokenPayload.iss) {\r\n      return { isValid: false, reason: 'Issuer does not match' };\r\n    }\r\n    // 3: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified by the iss (issuer) Claim as an audience. The aud (audience) Claim MAY contain an array with more than one element. The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences not trusted by the Client.\r\n\r\n    // 6: If the ID Token is received via direct communication between the Client and the Token Endpoint (which it is in this flow), the TLS server validation MAY be used to validate the issuer in place of checking the token signature. The Client MUST validate the signature of all other ID Tokens according to JWS [JWS] using the algorithm specified in the JWT alg Header Parameter. The Client MUST use the keys provided by the Issuer.\r\n\r\n    // 9: The current time MUST be before the time represented by the exp Claim.\r\n    const currentTimeUnixSecond = new Date().getTime() / 1000;\r\n    if (idTokenPayload.exp && idTokenPayload.exp < currentTimeUnixSecond) {\r\n      return { isValid: false, reason: 'Token expired' };\r\n    }\r\n    // 10: The iat Claim can be used to reject tokens that were issued too far away from the current time, limiting the amount of time that nonces need to be stored to prevent attacks. The acceptable range is Client specific.\r\n    const timeInSevenDays = 60 * 60 * 24 * 7;\r\n    if (\r\n      idTokenPayload.iat &&\r\n      idTokenPayload.iat + timeInSevenDays < currentTimeUnixSecond\r\n    ) {\r\n      return { isValid: false, reason: 'Token is used from too long time' };\r\n    }\r\n    // 11: If a nonce value was sent in the Authentication Request, a nonce Claim MUST be present and its value checked to verify that it is the same value as the one that was sent in the Authentication Request. The Client SHOULD check the nonce value for replay attacks. The precise method for detecting replay attacks is Client specific.\r\n    if (idTokenPayload.nonce && idTokenPayload.nonce !== nonce) {\r\n      return { isValid: false, reason: 'Nonce does not match' };\r\n    }\r\n  }\r\n  return { isValid: true, reason: '' };\r\n};\r\n\r\nfunction hideTokens(currentDatabaseElement: OidcConfig) {\r\n  const configurationName = currentDatabaseElement.configurationName;\r\n  return (response: Response) => {\r\n    if (response.status !== 200) {\r\n      return response;\r\n    }\r\n    return response.json().then<Response>((tokens: Tokens) => {\r\n      if (!tokens.issued_at) {\r\n        const currentTimeUnixSecond = new Date().getTime() / 1000;\r\n        tokens.issued_at = currentTimeUnixSecond;\r\n      }\r\n\r\n      const accessTokenPayload = extractTokenPayload(tokens.access_token);\r\n      const secureTokens = {\r\n        ...tokens,\r\n        access_token: TOKEN.ACCESS_TOKEN + '_' + configurationName,\r\n        accessTokenPayload,\r\n      };\r\n      tokens.accessTokenPayload = accessTokenPayload;\r\n\r\n      let _idTokenPayload = null;\r\n      if (tokens.id_token) {\r\n        _idTokenPayload = extractTokenPayload(tokens.id_token);\r\n        tokens.idTokenPayload = { ..._idTokenPayload };\r\n        if (_idTokenPayload.nonce && currentDatabaseElement.nonce != null) {\r\n          const keyNonce =\r\n            TOKEN.NONCE_TOKEN + '_' + currentDatabaseElement.configurationName;\r\n          _idTokenPayload.nonce = keyNonce;\r\n        }\r\n        secureTokens.idTokenPayload = _idTokenPayload;\r\n      }\r\n      if (tokens.refresh_token) {\r\n        secureTokens.refresh_token =\r\n          TOKEN.REFRESH_TOKEN + '_' + configurationName;\r\n      }\r\n\r\n      const idTokenExpiresAt =\r\n        _idTokenPayload && _idTokenPayload.exp\r\n          ? _idTokenPayload.exp\r\n          : Number.MAX_VALUE;\r\n      const accessTokenExpiresAt =\r\n        accessTokenPayload && accessTokenPayload.exp\r\n          ? accessTokenPayload.exp\r\n          : tokens.issued_at + tokens.expires_in;\r\n\r\n      let expiresAt: number;\r\n      const tokenRenewMode = (\r\n        currentDatabaseElement.oidcConfiguration as OidcConfiguration\r\n      ).token_renew_mode;\r\n      if (tokenRenewMode === TokenRenewMode.access_token_invalid) {\r\n        expiresAt = accessTokenExpiresAt;\r\n      } else if (tokenRenewMode === TokenRenewMode.id_token_invalid) {\r\n        expiresAt = idTokenExpiresAt;\r\n      } else {\r\n        expiresAt =\r\n          idTokenExpiresAt < accessTokenExpiresAt\r\n            ? idTokenExpiresAt\r\n            : accessTokenExpiresAt;\r\n      }\r\n      secureTokens.expiresAt = expiresAt;\r\n\r\n      tokens.expiresAt = expiresAt;\r\n      const nonce = currentDatabaseElement.nonce\r\n        ? currentDatabaseElement.nonce.nonce\r\n        : null;\r\n      const { isValid, reason } = isTokensOidcValid(\r\n        tokens,\r\n        nonce,\r\n        currentDatabaseElement.oidcServerConfiguration as OidcServerConfiguration\r\n      ); //TODO: Type assertion, could be null.\r\n      if (!isValid) {\r\n        throw Error(`Tokens are not OpenID valid, reason: ${reason}`);\r\n      }\r\n\r\n      // When refresh_token is not rotated we reuse ald refresh_token\r\n      if (\r\n        currentDatabaseElement.tokens != null &&\r\n        'refresh_token' in currentDatabaseElement.tokens &&\r\n        !('refresh_token' in tokens)\r\n      ) {\r\n        const refreshToken = currentDatabaseElement.tokens.refresh_token;\r\n\r\n        currentDatabaseElement.tokens = {\r\n          ...tokens,\r\n          refresh_token: refreshToken,\r\n        };\r\n      } else {\r\n        currentDatabaseElement.tokens = tokens;\r\n      }\r\n\r\n      currentDatabaseElement.status = 'LOGGED_IN';\r\n      const body = JSON.stringify(secureTokens);\r\n      return new Response(body, response);\r\n    });\r\n  };\r\n}\r\n\r\nexport {\r\n  b64DecodeUnicode,\r\n  computeTimeLeft,\r\n  isTokensValid,\r\n  extractTokenPayload,\r\n  isTokensOidcValid,\r\n  hideTokens\r\n};\r\n","import { FetchHeaders } from '../types';\r\n\r\nfunction serializeHeaders(headers: Headers) {\r\n  const headersObj: Record<string, string> = {};\r\n  for (const key of (headers as FetchHeaders).keys()) {\r\n    if (headers.has(key)) {\r\n      headersObj[key] = headers.get(key) as string;\r\n    }\r\n  }\r\n  return headersObj;\r\n}\r\nexport {serializeHeaders};","const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\r\nexport { sleep };\r\n","import { acceptAnyDomainToken, TOKEN, scriptFilename } from './constants';\r\nimport {\r\n  TrustedDomains,\r\n  Database,\r\n  OidcConfig,\r\n  OidcConfiguration,\r\n  MessageEventData,\r\n} from './types';\r\nimport {\r\n  checkDomain,\r\n  getCurrentDatabaseDomain,\r\n  hideTokens,\r\n  isTokensValid,\r\n  serializeHeaders,\r\n  sleep,\r\n} from './utils';\r\n\r\nconst _self = self as ServiceWorkerGlobalScope & typeof globalThis;\r\n\r\ndeclare let trustedDomains: TrustedDomains;\r\n\r\n_self.importScripts(scriptFilename);\r\n\r\nconst id = Math.round(new Date().getTime() / 1000).toString();\r\n\r\nconst keepAliveJsonFilename = 'OidcKeepAliveServiceWorker.json';\r\nconst handleInstall = (event: ExtendableEvent) => {\r\n  console.log('[OidcServiceWorker] service worker installed ' + id);\r\n  event.waitUntil(_self.skipWaiting());\r\n};\r\n\r\nconst handleActivate = (event: ExtendableEvent) => {\r\n  console.log('[OidcServiceWorker] service worker activated ' + id);\r\n  event.waitUntil(_self.clients.claim());\r\n};\r\n\r\nlet currentLoginCallbackConfigurationName: string | null = null;\r\nconst database: Database = {\r\n  default: {\r\n    configurationName: 'default',\r\n    tokens: null,\r\n    status: null,\r\n    state: null,\r\n    codeVerifier: null,\r\n    nonce: null,\r\n    oidcServerConfiguration: null,\r\n  },\r\n};\r\n\r\nconst getCurrentDatabasesTokenEndpoint = (database: Database, url: string) => {\r\n  const databases: OidcConfig[] = [];\r\n  for (const [, value] of Object.entries<OidcConfig>(database)) {\r\n    if (\r\n      value.oidcServerConfiguration != null &&\r\n      url.startsWith(value.oidcServerConfiguration.tokenEndpoint)\r\n    ) {\r\n      databases.push(value);\r\n    } else if (\r\n      value.oidcServerConfiguration != null &&\r\n      value.oidcServerConfiguration.revocationEndpoint &&\r\n      url.startsWith(value.oidcServerConfiguration.revocationEndpoint)\r\n    ) {\r\n      databases.push(value);\r\n    }\r\n  }\r\n  return databases;\r\n};\r\n\r\nconst keepAliveAsync = async (event: FetchEvent) => {\r\n  const originalRequest = event.request;\r\n  const isFromVanilla = originalRequest.headers.has('oidc-vanilla');\r\n  const init = { status: 200, statusText: 'oidc-service-worker' };\r\n  const response = new Response('{}', init);\r\n  if (!isFromVanilla) {\r\n    for (let i = 0; i < 240; i++) {\r\n      await sleep(1000 + Math.floor(Math.random() * 1000));\r\n      const cache = await caches.open('oidc_dummy_cache');\r\n      await cache.put(event.request, response.clone());\r\n    }\r\n  }\r\n\r\n  return response;\r\n};\r\n\r\nconst handleFetch = async (event: FetchEvent) => {\r\n  const originalRequest = event.request;\r\n  const url = originalRequest.url;\r\n  if (originalRequest.url.includes(keepAliveJsonFilename)) {\r\n    event.respondWith(keepAliveAsync(event));\r\n    return;\r\n  }\r\n\r\n  const currentDatabaseForRequestAccessToken = getCurrentDatabaseDomain(\r\n    database,\r\n    originalRequest.url,\r\n    trustedDomains\r\n  );\r\n  if (\r\n    currentDatabaseForRequestAccessToken &&\r\n    currentDatabaseForRequestAccessToken.tokens &&\r\n    currentDatabaseForRequestAccessToken.tokens.access_token\r\n  ) {\r\n    while (\r\n      currentDatabaseForRequestAccessToken.tokens &&\r\n      !isTokensValid(currentDatabaseForRequestAccessToken.tokens)\r\n    ) {\r\n      await sleep(200);\r\n    }\r\n    const newRequest = new Request(originalRequest, {\r\n      headers: {\r\n        ...serializeHeaders(originalRequest.headers),\r\n        authorization:\r\n          'Bearer ' + currentDatabaseForRequestAccessToken.tokens.access_token,\r\n      },\r\n      mode: (\r\n        currentDatabaseForRequestAccessToken.oidcConfiguration as OidcConfiguration\r\n      ).service_worker_convert_all_requests_to_cors\r\n        ? 'cors'\r\n        : originalRequest.mode,\r\n    });\r\n\r\n    //@ts-ignore -- TODO: review, waitUntil takes a promise, this returns a void\r\n    event.waitUntil(event.respondWith(fetch(newRequest)));\r\n\r\n    return;\r\n  }\r\n\r\n  if (event.request.method !== 'POST') {\r\n    return;\r\n  }\r\n\r\n  let currentDatabase: OidcConfig | null = null;\r\n  const currentDatabases = getCurrentDatabasesTokenEndpoint(\r\n    database,\r\n    originalRequest.url\r\n  );\r\n  const numberDatabase = currentDatabases.length;\r\n  if (numberDatabase > 0) {\r\n    const maPromesse = new Promise<Response>((resolve, reject) => {\r\n      const clonedRequest = originalRequest.clone();\r\n      const response = clonedRequest.text().then((actualBody) => {\r\n        if (\r\n          actualBody.includes(TOKEN.REFRESH_TOKEN) ||\r\n          actualBody.includes(TOKEN.ACCESS_TOKEN)\r\n        ) {\r\n          let newBody = actualBody;\r\n          for (let i = 0; i < numberDatabase; i++) {\r\n            const currentDb = currentDatabases[i];\r\n\r\n            if (currentDb && currentDb.tokens != null) {\r\n              const keyRefreshToken =\r\n                TOKEN.REFRESH_TOKEN + '_' + currentDb.configurationName;\r\n              if (actualBody.includes(keyRefreshToken)) {\r\n                newBody = newBody.replace(\r\n                  keyRefreshToken,\r\n                  encodeURIComponent(currentDb.tokens.refresh_token as string)\r\n                );\r\n                currentDatabase = currentDb;\r\n                break;\r\n              }\r\n              const keyAccessToken =\r\n                TOKEN.ACCESS_TOKEN + '_' + currentDb.configurationName;\r\n              if (actualBody.includes(keyAccessToken)) {\r\n                newBody = newBody.replace(\r\n                  keyAccessToken,\r\n                  encodeURIComponent(currentDb.tokens.access_token)\r\n                );\r\n                currentDatabase = currentDb;\r\n                break;\r\n              }\r\n            }\r\n          }\r\n          const fetchPromise = fetch(originalRequest, {\r\n            body: newBody,\r\n            method: clonedRequest.method,\r\n            headers: {\r\n              ...serializeHeaders(originalRequest.headers),\r\n            },\r\n            mode: clonedRequest.mode,\r\n            cache: clonedRequest.cache,\r\n            redirect: clonedRequest.redirect,\r\n            referrer: clonedRequest.referrer,\r\n            credentials: clonedRequest.credentials,\r\n            integrity: clonedRequest.integrity,\r\n          });\r\n\r\n          if (\r\n            currentDatabase &&\r\n            currentDatabase.oidcServerConfiguration != null &&\r\n            currentDatabase.oidcServerConfiguration.revocationEndpoint &&\r\n            url.startsWith(\r\n              currentDatabase.oidcServerConfiguration.revocationEndpoint\r\n            )\r\n          ) {\r\n            return fetchPromise.then(async (response) => {\r\n              const text = await response.text();\r\n              return new Response(text, response);\r\n            });\r\n          }\r\n          return fetchPromise.then(hideTokens(currentDatabase as OidcConfig)); //todo type assertion to OidcConfig but could be null, NEEDS REVIEW\r\n        } else if (\r\n          actualBody.includes('code_verifier=') &&\r\n          currentLoginCallbackConfigurationName\r\n        ) {\r\n          currentDatabase = database[currentLoginCallbackConfigurationName];\r\n          currentLoginCallbackConfigurationName = null;\r\n          let newBody = actualBody;\r\n          if (currentDatabase && currentDatabase.codeVerifier != null) {\r\n            const keyCodeVerifier =\r\n              TOKEN.CODE_VERIFIER + '_' + currentDatabase.configurationName;\r\n            if (actualBody.includes(keyCodeVerifier)) {\r\n              newBody = newBody.replace(\r\n                keyCodeVerifier,\r\n                currentDatabase.codeVerifier\r\n              );\r\n            }\r\n          }\r\n\r\n          return fetch(originalRequest, {\r\n            body: newBody,\r\n            method: clonedRequest.method,\r\n            headers: {\r\n              ...serializeHeaders(originalRequest.headers),\r\n            },\r\n            mode: clonedRequest.mode,\r\n            cache: clonedRequest.cache,\r\n            redirect: clonedRequest.redirect,\r\n            referrer: clonedRequest.referrer,\r\n            credentials: clonedRequest.credentials,\r\n            integrity: clonedRequest.integrity,\r\n          }).then(hideTokens(currentDatabase));\r\n        }\r\n        return undefined;\r\n      });\r\n      response\r\n        .then((r) => {\r\n          if (r !== undefined) {\r\n            resolve(r);\r\n          } else {\r\n            console.log('success undefined');\r\n            reject(new Error('Response is undefined inside a success'));\r\n          }\r\n        })\r\n        .catch((err) => {\r\n          if (err !== undefined) {\r\n            reject(err);\r\n          } else {\r\n            console.log('error undefined');\r\n            reject(new Error('Response is undefined inside a error'));\r\n          }\r\n        });\r\n    });\r\n\r\n    //@ts-ignore -- TODO: review, waitUntil takes a promise, this returns a void\r\n    event.waitUntil(event.respondWith(maPromesse));\r\n  }\r\n};\r\n\r\nconst handleMessage = (event: ExtendableMessageEvent) => {\r\n  const port = event.ports[0];\r\n  const data = event.data as MessageEventData;\r\n  const configurationName = data.configurationName;\r\n  let currentDatabase = database[configurationName];\r\n\r\n  if (!currentDatabase) {\r\n    database[configurationName] = {\r\n      tokens: null,\r\n      state: null,\r\n      codeVerifier: null,\r\n      oidcServerConfiguration: null,\r\n      oidcConfiguration: undefined,\r\n      nonce: null,\r\n      status: null,\r\n      configurationName,\r\n    };\r\n    currentDatabase = database[configurationName];\r\n    if (!trustedDomains[configurationName]) {\r\n      trustedDomains[configurationName] = [];\r\n    }\r\n  }\r\n\r\n  switch (data.type) {\r\n    case 'clear':\r\n      currentDatabase.tokens = null;\r\n      currentDatabase.state = null;\r\n      currentDatabase.codeVerifier = null;\r\n      currentDatabase.status = data.data.status;\r\n      port.postMessage({ configurationName });\r\n      return;\r\n    case 'init': {\r\n      const oidcServerConfiguration = data.data.oidcServerConfiguration;\r\n      const domains = trustedDomains[configurationName];\r\n      if (!domains.find((f) => f === acceptAnyDomainToken)) {\r\n        [\r\n          oidcServerConfiguration.tokenEndpoint,\r\n          oidcServerConfiguration.revocationEndpoint,\r\n          oidcServerConfiguration.userInfoEndpoint,\r\n          oidcServerConfiguration.issuer,\r\n        ].forEach((url) => {\r\n          checkDomain(domains, url);\r\n        });\r\n      }\r\n      currentDatabase.oidcServerConfiguration = oidcServerConfiguration;\r\n      currentDatabase.oidcConfiguration = data.data.oidcConfiguration;\r\n      const where = data.data.where;\r\n      if (\r\n        where === 'loginCallbackAsync' ||\r\n        where === 'tryKeepExistingSessionAsync'\r\n      ) {\r\n        currentLoginCallbackConfigurationName = configurationName;\r\n      } else {\r\n        currentLoginCallbackConfigurationName = null;\r\n      }\r\n\r\n      if (!currentDatabase.tokens) {\r\n        port.postMessage({\r\n          tokens: null,\r\n          status: currentDatabase.status,\r\n          configurationName,\r\n        });\r\n      } else {\r\n        const tokens = {\r\n          ...currentDatabase.tokens,\r\n          access_token: TOKEN.ACCESS_TOKEN + '_' + configurationName,\r\n        };\r\n        if (tokens.refresh_token) {\r\n          tokens.refresh_token = TOKEN.REFRESH_TOKEN + '_' + configurationName;\r\n        }\r\n        if (\r\n          tokens.idTokenPayload &&\r\n          tokens.idTokenPayload.nonce &&\r\n          currentDatabase.nonce != null\r\n        ) {\r\n          tokens.idTokenPayload.nonce =\r\n            TOKEN.NONCE_TOKEN + '_' + configurationName;\r\n        }\r\n        port.postMessage({\r\n          tokens,\r\n          status: currentDatabase.status,\r\n          configurationName,\r\n        });\r\n      }\r\n      return;\r\n    }\r\n    case 'setState':\r\n      currentDatabase.state = data.data.state;\r\n      port.postMessage({ configurationName });\r\n      return;\r\n    case 'getState': {\r\n      const state = currentDatabase.state;\r\n      port.postMessage({ configurationName, state });\r\n      return;\r\n    }\r\n    case 'setCodeVerifier':\r\n      currentDatabase.codeVerifier = data.data.codeVerifier;\r\n      port.postMessage({ configurationName });\r\n      return;\r\n    case 'getCodeVerifier': {\r\n      port.postMessage({\r\n        configurationName,\r\n        codeVerifier: TOKEN.CODE_VERIFIER + '_' + configurationName,\r\n      });\r\n      return;\r\n    }\r\n    case 'setSessionState':\r\n      currentDatabase.sessionState = data.data.sessionState;\r\n      port.postMessage({ configurationName });\r\n      return;\r\n    case 'getSessionState': {\r\n      const sessionState = currentDatabase.sessionState;\r\n      port.postMessage({ configurationName, sessionState });\r\n      return;\r\n    }\r\n    case 'setNonce':\r\n      currentDatabase.nonce = data.data.nonce;\r\n      port.postMessage({ configurationName });\r\n      return;\r\n    default:\r\n      currentDatabase.items = { ...data.data };\r\n      port.postMessage({ configurationName });\r\n  }\r\n};\r\n\r\n_self.addEventListener('install', handleInstall);\r\n_self.addEventListener('activate', handleActivate);\r\n_self.addEventListener('fetch', handleFetch);\r\n_self.addEventListener('message', handleMessage);\r\n"],"names":["scriptFilename","acceptAnyDomainToken","TOKEN","TokenRenewMode","openidWellknownUrlEndWith","checkDomain","domains","endpoint","domain","_a","testable","getCurrentDatabaseDomain","database","url","trustedDomains","key","currentDatabase","oidcServerConfiguration","domainsToSendTokens","hasToSendToken","f","i","countLetter","str","find","parseJwt","token","b64DecodeUnicode","c","computeTimeLeft","refreshTimeBeforeTokensExpirationInSecond","expiresAt","currentTimeUnixSecond","isTokensValid","tokens","extractTokenPayload","e","isTokensOidcValid","nonce","idTokenPayload","timeInSevenDays","hideTokens","currentDatabaseElement","configurationName","response","accessTokenPayload","secureTokens","_idTokenPayload","keyNonce","idTokenExpiresAt","accessTokenExpiresAt","tokenRenewMode","isValid","reason","refreshToken","body","serializeHeaders","headers","headersObj","sleep","ms","resolve","_self","id","keepAliveJsonFilename","handleInstall","event","handleActivate","currentLoginCallbackConfigurationName","getCurrentDatabasesTokenEndpoint","databases","value","keepAliveAsync","isFromVanilla","init","handleFetch","originalRequest","currentDatabaseForRequestAccessToken","newRequest","currentDatabases","numberDatabase","maPromesse","reject","clonedRequest","actualBody","newBody","currentDb","keyRefreshToken","keyAccessToken","fetchPromise","text","keyCodeVerifier","r","err","handleMessage","port","data","where","state","sessionState"],"mappings":"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"}